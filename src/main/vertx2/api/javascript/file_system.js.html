<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: vertx/file_system.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: vertx/file_system.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*
 * Copyright 2011-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

if (typeof __vertxload === 'string') {
  throw "Use require() to load Vert.x API modules"
}


var jfs = __jvertx.fileSystem();

/**
 * File system operations are handled asynchronously. The result of the operations
 * are given to a &lt;code>ResultHandler&lt;/code>. The &lt;code>ResultHandler&lt;/code> is 
 * just a {@linkcode Handler} that accepts two parameters: 1) an exception object
 * if an error occurred; and 2) the result of the operation, the type of which is
 * determined by the firing event.
 *
 * @typedef {function} ResultHandler
 * @param {Exception} cause This will be &lt;code>null&lt;/code> if the operation succeeded
 * @param {{}} result The result of the operation event this handler cares about
 */

/**
 * @exports vertx/file_system
 */
var fileSystem = {};

load("vertx/read_stream.js");
load("vertx/write_stream.js");

function wrapHandler(handler) {
  return function(asyncResult) {
    if (asyncResult.succeeded()) {
      handler(null, asyncResult.result());
    } else {
      handler(asyncResult.cause(), null);
    }
  }
}

function wrapPropsHandler(handler) {
  return function(asyncResult) {
    if (asyncResult.succeeded()) {
      var jsProps = convertProps(asyncResult.result());
      handler(null, jsProps);
    } else {
      handler(asyncResult.cause(), null);
    }
  }
}

function convertProps(j_props) {
  /** 
   * @typedef {{}} FileProps 
   * @property {date} creationTime The date the file was created
   * @property {date} lastAccessTime The date the file was last accessed
   * @property {date} lastModifiedTime The date the file was last modified
   * @property {boolean} isDirectory is the file a directory?
   * @property {boolean} isOther Is the file some other type? I.e. not a directory, regular file or symbolic link
   * @property {boolean} isRegularFile is the file a regular file?
   * @property {boolean} isSymbolicLink is the file a symlink?
   * @property {number} size the size of the file in bytes
   * */
  return {
    creationTime: j_props.creationTime().getTime(),
    lastAccessTime: j_props.lastAccessTime().getTime(),
    lastModifiedTime: j_props.lastModifiedTime().getTime(),
    isDirectory: j_props.isDirectory(),
    isOther: j_props.isOther(),
    isRegularFile: j_props.isRegularFile(),
    isSymbolicLink: j_props.isSymbolicLink(),
    size: j_props.size()
  }
}

/**
 * Copy a file, asynchronously. The copy will fail if &lt;code>from&lt;/code> 
 * does not exist, or if &lt;code>to&lt;/code> already exists.
 *
 * @param {string} from path of file to copy
 * @param {string} to path of file to copy to
 * @param {boolean} [recursive] copy recursively (default is false)
 * @param {ResultHandler} handler the handler which is called on completion.
 * @returns {module:vertx/file_system}
 */
fileSystem.copy = function(from, to, arg2, arg3) {
  var handler;
  var recursive;
  if (arguments.length === 4) {
    handler = arg3;
    recursive = arg2;
  } else {
    handler = arg2;
    recursive = false;
  }
  jfs.copy(from, to, recursive, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of copy
 *
 * @param {string} from the path of the file to copy
 * @param {string} to the path to copy the file to
 * @param {boolean} recursive copy recursively (default is false)
 * @returns {module:vertx/file_system}
 */
fileSystem.copySync = function(from, to, recursive) {
  if (!recursive) recursive = false;
  jfs.copySync(from, to, recursive);
  return fileSystem;
}

/**
 * Move a file, asynchronously. The move will fail if &lt;code>from&lt;/code> 
 * does not exist, or if &lt;code>to&lt;/code> already exists.
 *
 * @param {string} from the path of file to move
 * @param {string} to the path to move the file to
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.move = function(from, to, handler) {
  jfs.move(from, to, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of move.
 *
 * @param {string} from the path of file to move
 * @param {string} to the path to move the file to
 * @returns {module:vertx/file_system}
 */
fileSystem.moveSync = function(from, to) {
  jfs.moveSync(from, to);
  return fileSystem;
}

/**
 * Truncate a file, asynchronously. The move will fail if path does not exist.
 *
 * @param {string} path Path of file to truncate
 * @param {number} len Length to truncate file to. Will fail if len &lt; 0. If len > file size then will do nothing.
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.truncate = function(path, len, handler) {
  jfs.truncate(path, len, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of truncate.
 *
 * @param {string} path Path of file to truncate
 * @param {number} len Length to truncate file to. Will fail if len &lt; 0. If len > file size then will do nothing.
 * @returns {module:vertx/file_system}
 */
fileSystem.truncateSync = function(path, len) {
  jfs.truncateSync(path, len);
  return fileSystem;
}

/**
 * Change the permissions on a file, asynchronously. If the file is directory
 * then all contents will also have their permissions changed recursively.
 *
 * @param {string} path path of file to change permissions
 * @param {string} perms a permission string of the form rwxr-x--- as specified
 * in http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html.
 * This is used to set the permissions for any regular files (not directories).
 * @param {string} [dir_perms] similar to &lt;code>perms&lt;/code> above, but refers only to directories.
 * @param {ResultHandler} handler The handler to call when the operation has completed
 *
 * @returns {module:vertx/file_system}
 */
fileSystem.chmod = function(path, perms, arg2, arg3) {
  var handler;
  var dirPerms;
  if (arguments.length === 4) {
    handler = arg3;
    dirPerms = arg2;
  } else {
    handler = arg2;
    dirPerms = null;
  }
  jfs.chmod(path, perms, dirPerms, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of chmod.
 *
 * @param {string} path path of file to change permissions
 * @param {string} perms a permission string of the form rwxr-x--- as specified
 * in http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html.
 * This is used to set the permissions for any regular files (not directories).
 * @param {string} [dir_perms] similar to &lt;code>perms&lt;/code> above, but refers only to directories.
 * @returns {module:vertx/file_system}
 */
fileSystem.chmodSync = function(path, perms, dirPerms) {
  if (!dirPerms) dirPerms = null;
  jfs.chmodSync(path, perms, dirPerms);
  return fileSystem;
}

/**
 * Get file properties for a file, asynchronously.
 *
 * @param {string} path path to file
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.props = function(path, handler) {
  jfs.props(path, wrapPropsHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of props.
 * @param {string} path path to file
 * @returns {FileProps}
 */
fileSystem.propsSync = function(path) {
  var j_props = jfs.propsSync(path);
  return convertProps(j_props);
}

/**
 * Obtain properties for the link represented by &lt;code>path&lt;/code>, asynchronously.
 * The link will not be followed.
 *
 * @param {string} path path to file
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.lprops = function(path, handler) {
  jfs.lprops(path, wrapPropsHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of lprops.
 *
 * @param {string} path path to file
 * @returns {FileProps}
 */
fileSystem.lpropsSync = function(path) {
  var j_props = jfs.lpropsSync(path);
  return convertProps(j_props);
}

/**
 * Create a hard link, asynchronously.
 *
 * @param {string} link path of the link to create.
 * @param {string} existing path of where the link points to.
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.link = function(link, existing, handler) {
  jfs.link(link, existing, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of link.
 * @param {string} link path of the link to create.
 * @param {string} existing path of where the link points to.
 * @returns {module:vertx/file_system}
 */
fileSystem.linkSync = function(link, existing) {
  jfs.linkSync(link, existing);
  return fileSystem;
}

/**
 * Create a symbolic link, asynchronously.
 *
 * @param {string} link Path of the link to create.
 * @param {string} existing Path of where the link points to.
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.symlink = function(link, existing, handler) {
  jfs.symlink(link, existing, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of symlink.
 * @param {string} link Path of the link to create.
 * @param {string} existing Path of where the link points to.
 * @returns {module:vertx/file_system}
 */
fileSystem.symlinkSync = function(link, existing) {
  jfs.symlinkSync(link, existing);
  return fileSystem;
}

/**
 * Unlink a hard link.
 *
 * @param {string} link path of the link to unlink.
 * @param {ResultHandler} handler the handler to notify on completion.
 * @returns {module:vertx/file_system}
 */
fileSystem.unlink = function(link, handler) {
  jfs.unlink(link, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of unlink.
 *
 * @param {string} link path of the link to unlink.
 * @returns {module:vertx/file_system}
 */
fileSystem.unlinkSync = function(link) {
  jfs.unlinkSync(link);
  return fileSystem;
}

/**
 * Read a symbolic link, asynchronously. I.e. tells you where the symbolic link points.
 *
 * @param {string} link path of the link to read.
 * @param {ResultHandler} handler the function to call when complete, the function will be 
 *        called with a string representing the path of the file that the &lt;code>link&lt;/code>
 *        symlink is linked to.
 * @returns {module:vertx/file_system}
 */
fileSystem.readSymlink = function(link, handler) {
  jfs.readSymlink(link, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of readSymlink.
 *
 * @param {string} link path of the link to read.
 * @returns {string} the path of the file that the &lt;code>link&lt;/code> symlink is linked to.
 */
fileSystem.readSymlinkSync = function(link) {
  return jfs.readSymlinkSync(link);
}

/**
 * Delete a file on the file system, asynchronously.
 * The delete will fail if the file does not exist, or is a directory and is not empty.
 *
 * @param {string} path path of the file to delete.
 * @param {boolean} [recursive] recurse into subdirectories (default: false)
 * @param {ResultHandler} handler The handler to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.delete = function(path, arg1, arg2) {
  var handler;
  var recursive;
  if (arguments.length === 3) {
    handler = arg2;
    recursive = arg1;
  } else {
    handler = arg1;
    recursive = false;
  }
  jfs.delete(path, recursive, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of delete.
 *
 * @param {string} path path of the file to delete.
 * @param {boolean} [recursive] recurse into subdirectories (default: false)
 * @returns {module:vertx/file_system}
 */
fileSystem.deleteSync = function(path, recursive) {
  if (!recursive) recursive = false;
  jfs.deleteSync(path, recursive);
  return fileSystem;
}

/**
 * Create a directory, asynchronously.  The create will fail if the directory
 * already exists, or if it contains parent directories which do not already
 * exist.
 *
 * @param {string} path path of the directory to create.
 * @param {boolean} [createParents] create parent directories if necesssary (default is false)
 * @param {string} [permString] the permissions of the directory being created
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.mkDir = function(path, arg1, arg2, arg3) {
  var createParents;
  var perms;
  var handler;
  switch (arguments.length) {
    case 2:
      createParents = false;
      perms = null;
      handler = arg1;
      break;
    case 3:
      if (typeof(arg1) === 'boolean') {
        createParents = arg1;
        perms=null;
      } else {
        createParents = false;
        perms = arg1;
      }
      handler = arg2;
      break;
    case 4:
      createParents = arg1;
      perms = arg2;
      handler = arg3;
      break;
    default:
      throw 'Invalid number of arguments';
  }
  jfs.mkdir(path, perms, createParents, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of mkdir.
 *
 * @param {string} path path of the directory to create.
 * @param {boolean} [createParents] create parent directories if necesssary (default is false)
 * @param {string} [permString] the permissions of the directory being created
 * @returns {module:vertx/file_system}
 */
fileSystem.mkDirSync = function(path, arg1, arg2) {
  var createParents;
  var perms;
  switch (arguments.length) {
    case 1:
      createParents = false;
      perms = null;
      break;
    case 2:
      createParents = arg1;
      perms = null;
      break;
    case 3:
      createParents = arg1;
      perms = arg2;
      break;
    default:
      throw 'Invalid number of arguments';
  }
  jfs.mkdirSync(path, perms, createParents);
  return fileSystem;
}

/**
 * Read a directory, i.e. list it's contents, asynchronously.
 * The read will fail if the directory does not exist.
 *
 * @param {string} path path of the directory to read.
 * @param {string} [filter] a regular expression. If supplied, only paths that match
 *        &lt;code>filter&lt;/code> will be passed to the &lt;code>handler&lt;/code>.
 * @param {ResultHandler} handler the handler to call when complete. The handler will be
 *        passed an array of strings each representing a matched path name.
 * @returns {module:vertx/file_system}
 */
fileSystem.readDir = function(path, arg1, arg2) {
  var filter;
  var handler;
  if (arguments.length === 3) {
    handler = arg2;
    filter = arg1;
  } else {
    handler = arg1;
    filter = null;
  }
  jfs.readDir(path, filter, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of readDir.
 *
 * @param {string} path path of the directory to read.
 * @param {string} [filter] a regular expression. If supplied, only paths that match
 *        &lt;code>filter&lt;/code> will be passed to the &lt;code>handler&lt;/code>.
 * @returns {Array} an array of strings, each representing a matched path name.
 */
fileSystem.readDirSync = function(path, filter) {
  if (!filter) filter = false;
  return jfs.readDirSync(path, filter);
}

/**
 * Read the contents of the entire file.
 *
 * @param {string} path path of the file to read.
 * @param {ResultHandler} handler the function to call when complete. The handler function
 *        will receive a Buffer containing the contents of the file.
 * @returns {module:vertx/file_system}
 */
fileSystem.readFile = function(path, handler) {
  jfs.readFile(path, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of readFile.
 *
 * @param {string} path path of the file to read.
 * @returns {Buffer} a Buffer containing the contents of the file.
 */
fileSystem.readFileSync = function(path) {
  return jfs.readFileSync(path);
}

/**
 * Write data to a file
 *
 * @param {string} path path of the file to write.
 * @param {string|Buffer} data the data to write
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.writeFile = function(path, data, handler) {
  if (typeof data === 'string') {
    data = new org.vertx.java.core.buffer.Buffer(data);
  }
  jfs.writeFile(path, data, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of writeFile.
 *
 * @param {string} path path of the file to write.
 * @param {string|Buffer} data the data to write
 * @returns {module:vertx/file_system}
 */
fileSystem.writeFileSync = function(path, data) {
  if (typeof data === 'string') {
    data = new org.vertx.java.core.buffer.Buffer(data);
  }
  jfs.writeFileSync(path, data);
  return fileSystem;
}

/** 
 * Flags used when opening files working with the vert.x 
 * {@linkcode module:vertx/file_system|FileSystem}
 * @typedef {number} Flag 
 * */

/** @property {Flag} OPEN_READ Open file for reading flag. */
fileSystem.OPEN_READ = 1;
/** @property {Flag} OPEN_WRITE Open file for writing flag. */
fileSystem.OPEN_WRITE = 2;
/** @property {Flag} CREATE_NEW Create new file flag. */
fileSystem.CREATE_NEW = 4;

/**
 * Synchronous version of open.
 *
 * @param {string} path the path of the file to open
 * @param {Flag} [openFlags] an integer representing whether to open the file for
 *        reading, writing, creation, or some combination of these with bitwise or
 *        (e.g. &lt;code>fileSystem.OPEN_READ | fileSystem.OPEN_WRITE&lt;/code>).  If not
 *        specified the file will be opened for reading, wrting, and creation.
 * @param {boolean} [flush] flush file writes immediately (default is false)
 * @param {string} [permissions] the permissions to create the file with if the
 *        file is created when opened.
 * @returns {AsyncFile}
 */
fileSystem.openSync = function(path, arg1, arg2, arg3) {
  // TODO combine this code with the similar code in open
  var openFlags;
  var flush;
  var perms;
  var handler;
  switch (arguments.length) {
    case 1:
      openFlags = fileSystem.OPEN_READ | fileSystem.OPEN_WRITE
                | fileSystem.CREATE_NEW;
      flush = false;
      perms = null;
      break;
    case 2:
      openFlags = arg1;
      flush = false;
      perms = null;
      break;
    case 3:
      openFlags = arg1;
      flush = arg2;
      perms = null;
      break;
    case 4:
      openFlags = arg1;
      flush = arg2;
      perms = arg3;
      break;
    default:
      throw 'Invalid number of arguments';
  }

  var read = (openFlags & fileSystem.OPEN_READ) == fileSystem.OPEN_READ;
  var write = (openFlags & fileSystem.OPEN_WRITE) == fileSystem.OPEN_WRITE;
  var createNew = (openFlags & fileSystem.CREATE_NEW) == fileSystem.CREATE_NEW;

  var asyncFile = jfs.openSync(path, perms, read, write, createNew, flush);

  return new fileSystem.AsyncFile(asyncFile);
}

/**
 * Open a file on the file system, asynchronously.
 *
 * @param {string} path the path of the file to open
 * @param {Flag} [openFlags] an integer representing whether to open the file for
 *        reading, writing, creation, or some combination of these with bitwise or
 *        (e.g. &lt;code>fileSystem.OPEN_READ | fileSystem.OPEN_WRITE&lt;/code>).  If not
 *        specified the file will be opened for reading, wrting, and creation.
 * @param {boolean} [flush] flush file writes immediately (default is false)
 * @param {string} [permissions] the permissions to create the file with if the
 *        file is created when opened.
 * @param {ResultHandler} handler the function to be called when the file is opened. The 
 *        handler will receieve an AsyncFile as a parameter when called.
 * @returns {module:vertx/file_system}
 */
fileSystem.open = function(path, arg1, arg2, arg3, arg4) {

  var openFlags;
  var flush;
  var perms;
  var handler;
  switch (arguments.length) {
    case 2:
      openFlags = fileSystem.OPEN_READ | fileSystem.OPEN_WRITE
                | fileSystem.CREATE_NEW;
      flush = false;
      perms = null;
      handler = arg1;
      break;
    case 3:
      openFlags = arg1;
      flush = false;
      perms = null;
        handler = arg2;
      break;
    case 4:
      openFlags = arg1;
      flush = arg2;
      perms = null;
      handler = arg3;
      break;
    case 5:
      openFlags = arg1;
      flush = arg2;
      perms = arg3;
      handler = arg4;
      break;
    default:
      throw 'Invalid number of arguments';
  }

  var read = (openFlags & fileSystem.OPEN_READ) == fileSystem.OPEN_READ;
  var write = (openFlags & fileSystem.OPEN_WRITE) == fileSystem.OPEN_WRITE;
  var createNew = (openFlags & fileSystem.CREATE_NEW) == fileSystem.CREATE_NEW;

  jfs.open(path, perms, read, write, createNew, flush, function(asyncResult) {
    if (asyncResult.succeeded()) {
      var jaf = asyncResult.result();
      var wrapped = new fileSystem.AsyncFile(jaf);
      handler(null, wrapped);
    } else {
      handler(asyncResult.cause(), null);
    }
  });
  return fileSystem;
}

 /**
 * &lt;p>
 * An &lt;code>AsyncFile&lt;/code> represents a file on the file-system which can be
 * read from, or written to asynchronously.  Methods also exist to get a
 * &lt;code>ReadStream&lt;/code> or a &lt;code>WriteStream&lt;/code> on the file. This
 * allows the data to be pumped to and from other streams. Instances of this
 * class are not thread-safe 
 * &lt;/p>
 * &lt;p>
 * These should not be created directly. Rather they are created internally
 * by vert.x and provided to callback handlers and as return values from
 * synchronous functions.
 * &lt;/p>
 * @constructor
 * @param {org.vertx.java.core.file.AsyncFile} asyncFile the underlying java representation of this AsyncFile
 * @mixes ReadStream
 * @mixes WriteStream
 */

fileSystem.AsyncFile = function(jaf) {
  var that = this;

  /**
   * Close the file asynchronously
   * @param {ResultHandler} handler the handler to be called when the operation completes
   */
  this.close = function(handler) {
    if (handler) {
      jaf.close(wrapHandler(handler))
    } else {
      jaf.close();
    }
  }

  /**
   * Write to the file asynchronously
   * @param {Buffer|string} buffer the data to write
   * @param {number} position the byte position from which to start writing
   * @param {ResultHandler} handler the handler to call when the write has completed
   * @returns {module:vertx/file_system}
   */
  this.write = function(buffer, position, handler) {
    jaf.write(buffer, position, wrapHandler(handler));
    return that;
  }

  /**
   * Read from the file asynchronously
   * @param {Buffer} buffer The buffer to fill with the contents of the file
   * @param {number} offset The offset point in the Buffer from which to start writing
   * @param {number} position The position in the file from which to begin reading
   * @param {number} length the number of bytes to read
   * @param {ResultHandler} handler the handler to call when close() has been completed and will
   *        be provided the filled Buffer as a parameter
   */
  this.read = function(buffer, offset, position, length, handler) {
    jaf.read(buffer, offset, position, length, wrapHandler(handler));
    return that;
  }

  /**
   * Flush any writes made to this file to persistent storage.
   * @param {ResultHandler} handler The handler to be called when the flush has completed
   */
  this.flush = function(handler) {
    if (handler) {
      jaf.flush(wrapHandler(handler));
    } else {
      jaf.flush();
    }
  }
  writeStream(this, jaf);
  readStream(this, jaf);
}

/**
 * Create a new empty file, asynchronously.
 *
 * @param {string} path path of the file to create.
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.createFile = function(path, handler) {
  jfs.createFile(path, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of createFile.
 *
 * @param {string} path path of the file to create.
 * @returns {module:vertx/file_system}
 */
fileSystem.createFileSync = function(path) {
  jfs.createFileSync(path);
  return fileSystem;
}

/**
 * Check if a file exists, asynchronously.
 *
 * @param {string} path Path of the file to check.
 * @param {ResultHandler} handler the function to call when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.exists = function(path, handler) {
  jfs.exists(path, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of exists.
 *
 * @param {string} path Path of the file to check.
 * @returns {boolean} &lt;code>true&lt;/code> if the file exists
 */
fileSystem.existsSync = function(path) {
  return jfs.existsSync(path);
}

/** 
 * @typedef {{}} FileSystemProps 
 * @property {number} totalSpace The total space on the file system, in bytes
 * @property {number} unallocatedSpace The total unallocated space on the file syste, in bytes
 * @property {number} usableSpace The total usable space on the file system, in bytes
 * */

/**
 * Asynchronously get properties for the file system being used by the 
 * &lt;code>path&lt;/code> specified.
 *
 * @param {string} path the path in the file system.
 * @param {ResultHandler} handler the function to call with the FileSystemProps when complete
 * @returns {module:vertx/file_system}
 */
fileSystem.fsProps = function(path, handler) {
  jfs.fsProps(path, wrapHandler(handler));
  return fileSystem;
}

/**
 * Synchronous version of fsProps.
 * @param {string} path Path in the file system.
 * @returns {FileSystemProps}
 */
fileSystem.fsPropsSync = function(path) {
  return jfs.fsPropsSync(path);
}

module.exports = fileSystem;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-vertx.html">vertx</a></li><li><a href="buffer.html">vertx/buffer</a></li><li><a href="console.html">vertx/console</a></li><li><a href="container.html">vertx/container</a></li><li><a href="event_bus.html">vertx/event_bus</a></li><li><a href="file_system.html">vertx/file_system</a></li><li><a href="http.html">vertx/http</a></li><li><a href="multi_map.html">vertx/multi_map</a></li><li><a href="net.html">vertx/net</a></li><li><a href="parse_tools.html">vertx/parse_tools</a></li><li><a href="pump.html">vertx/pump</a></li><li><a href="shared_data.html">vertx/shared_data</a></li><li><a href="sockjs.html">vertx/sockjs</a></li><li><a href="timer.html">vertx/timer</a></li></ul><h3>Externals</h3><ul><li><a href="InetSocketAddress.html">InetSocketAddress</a></li><li><a href="Buffer_.html">Buffer</a></li><li><a href="RecordParser.html">RecordParser</a></li><li><a href="SockJSSocket.html">SockJSSocket</a></li></ul><h3>Classes</h3><ul><li><a href="buffer-Buffer.html">Buffer</a></li><li><a href="file_system.AsyncFile.html">AsyncFile</a></li><li><a href="http.HttpClient.html">HttpClient</a></li><li><a href="http.HttpClientRequest.html">HttpClientRequest</a></li><li><a href="http.HttpClientResponse.html">HttpClientResponse</a></li><li><a href="http.HttpServer.html">HttpServer</a></li><li><a href="http.HttpServerFileUpload.html">HttpServerFileUpload</a></li><li><a href="http.HttpServerRequest.html">HttpServerRequest</a></li><li><a href="http.HttpServerResponse.html">HttpServerResponse</a></li><li><a href="http.RouteMatcher.html">RouteMatcher</a></li><li><a href="http.WebSocket.html">WebSocket</a></li><li><a href="multi_map-MultiMap.html">MultiMap</a></li><li><a href="net.NetClient.html">NetClient</a></li><li><a href="net.NetServer.html">NetServer</a></li><li><a href="net.NetSocket.html">NetSocket</a></li><li><a href="pump-Pump.html">Pump</a></li><li><a href="sockjs.SockJSServer.html">SockJSServer</a></li></ul><h3>Mixins</h3><ul><li><a href="ClientSSLSupport.html">ClientSSLSupport</a></li><li><a href="ReadStream.html">ReadStream</a></li><li><a href="ServerSSLSupport.html">ServerSSLSupport</a></li><li><a href="ServerTCPSupport.html">ServerTCPSupport</a></li><li><a href="SSLSupport.html">SSLSupport</a></li><li><a href="TCPSupport.html">TCPSupport</a></li><li><a href="WriteStream.html">WriteStream</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Wed Jul 17 2013 20:27:22 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
